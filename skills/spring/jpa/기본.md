-jpa 기본

    - 엔티티 매니저?
        - 생명주기
            - 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
            - 영속(managed) : 영속성 컨텍스트에 관리되는 상태
            - 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
            - 삭제(removed) : 삭제된 상태

    - 영속성 컨텍스트
        - 엔티티를 영구 저장하는 환경 (entityManager.persist(entity))
        - 엔티티 매니저를 통해 영속성 컨텍스트에 접근
        - 1차캐시
        - 동일성 보장
        - 트랙잭션을 지원하는 쓰기 지연
        - 변경감지 (dirty checking)
        - 지연로딩 (lazy loading)
        
    - 플러시
        - 영속성 컨텍스트의 변경내용을 데이터베이스에 반영(동기화)
        - 변경감지 -> 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 -> 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록,수정,삭제 쿼리)
        - 영속성 컨텍스트를 플러시하는 방법
            - em.flush : 직접호출
            - 트랙잭션 커밋 : 플러시 자동 호출
            - JPQL 쿼리 실행 : 플러시 자동 호출
        - 영속성 컨텍스트를 비우는게 아님
        - 트랜잭션이라는 작업 단위가 중요 - 커밋 직전에만 동기화 하면 됨

    - 준영속 상태
        - 영속 -> 준영속
        - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) -> 영속성 컨텍스트에서 더이상 관리하지마! JPA에서 관리안한다.
        - 영속성 컨텍스트가 제공하는 기능을 사용 못함
        - 준영속 상태로 만드는 방법
            - em.detach(entity) : 특정 엔티티만 준영속 상태로 전환
            - em.clear() : 영속성 컨텍스트를 완전히 초기화
            - em.close() : 영속성 컨텍스트를 종료


    - 엔티티 매핑
        - 객체와 테이블 매핑 
            - @Entity
                - jpa를 사용해서 테이브르과 매핑할 클래스는 @Entity 필수
                - 기본 생성자 필수(파라미터가 없는 public or protected 생성자)
                - final class, enum, interface, inner class 사용 x
                - 저장할 필드에 final 사용 x
            - @Table

            - 데이터베이스 스키마 자동 생성
                - hibernate.hbm2ddl.auto 
                    - create (기존테이블 삭제 후 다시 생성) --> 운영X
                    - create-drop (create 동일 종료시점에 테이블 drop) --> 운영X
                    - update (변경분만 반영) --> 운영X, 테스트o
                    - validate (엔티티와 테이블이 정상 매핑되었는지만 확인)
                    - none
                - DDL을 애플리케이션 실행 시점에 자동 생성
                - 테이블 중심 -> 객체 중심
                - 개발 장비에서만 사용!!! (생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용)

        - 필드와 컬럼 매핑
            - @Column : 컬럼 매핑
                - nullable = false -> not null 제약조건
                - columnDefinition 가능
            - @Temporal : 날짜 타입 매핑
                - LocalDate, LocalDateTime을 사용할 때는 생략 가능
            - @Enumerated : enum 타입 매핑
                - 주의! ORDINAL 사용X
                - EnumType.ORDINAL: enum 순서를 데이터베이스에 저장
                - EnumType.STRING: enum 이름을 데이터베이스에 저장
            - @Lob : BLOB, CLOB 매핑 
            - @Transient 특정 필드를 컬럼에 매핑하지 않음(매핑 무시)

        - 기본키 매핑 : @Id
            - 직접 할당: @Id만 사용
            - 자동 생성(@GeneratedValue) 
                - IDENTITY: 데이터베이스에 위임, MYSQL 
                    - AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행
한 이후에 ID 값을 알 수 있음
                    - IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행
하고 DB에서 식별자를 조회

                - SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE 
                    - @SequenceGenerator 필요
                    - 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한
데이터베이스 오브젝트(예: 오라클 시퀀스)

                - TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
                    - @TableGenerator 필요
                    - 모든 데이터베이스에 적용 가능
                    - 성능 (테이블락 걸릴수 있음)


                - AUTO: DB에 따라 자동 지정, 기본값

            - 권장하는 식별자 전략
                - Long형 + 대체키 + 키 생성전략 사용


        - 연관관계 매핑 : @ManyToOne, @JoinColumn
            - 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.

            - 방향
                - 단방향
                - 양방향
                    - 누구를 주인으로 할꺼냐? 외래키가 있는 곳을 주인으로 정하자!
                    - 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자 -> 연관관계 편의 메소드를 생성하자
                    - 무한 루프를조심하자
                        - toString() : 양쪽 객체를 호출해서 무한루프
                        - lombok
                        - JSON 생성 라이브러리
                    - 단방향 매핑만으로도 이미 연관관계 매핑은 완료 
                        - 처음에는 단방향으로 설계를 끝내야함
                        - 그 후 양방향으로 조회관련 설계를 추가한다.. 
                    - 실무에서는 JPQL에서 역방향으로 탐색할 일이 많음...

                    
            
            - 다중성
                - 다대일(N:1)
                - 일대다(1:N)
                - 일대일(1:1)
                - 다대다(N:M)

            - 연관관계의 주인(owner) : 객체 양방향 연관간계는 관리 주인이 필요
        