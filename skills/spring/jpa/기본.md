-jpa 기본

    - 엔티티 매니저?
        - 생명주기
            - 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
            - 영속(managed) : 영속성 컨텍스트에 관리되는 상태
            - 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
            - 삭제(removed) : 삭제된 상태

    - 영속성 컨텍스트
        - 엔티티를 영구 저장하는 환경 (entityManager.persist(entity))
        - 엔티티 매니저를 통해 영속성 컨텍스트에 접근
        - 1차캐시
        - 동일성 보장
        - 트랙잭션을 지원하는 쓰기 지연
        - 변경감지 (dirty checking)
        - 지연로딩 (lazy loading)
        
    - 플러시
        - 영속성 컨텍스트의 변경내용을 데이터베이스에 반영(동기화)
        - 변경감지 -> 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 -> 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록,수정,삭제 쿼리)
        - 영속성 컨텍스트를 플러시하는 방법
            - em.flush : 직접호출
            - 트랙잭션 커밋 : 플러시 자동 호출
            - JPQL 쿼리 실행 : 플러시 자동 호출
        - 영속성 컨텍스트를 비우는게 아님
        - 트랜잭션이라는 작업 단위가 중요 - 커밋 직전에만 동기화 하면 됨

    - 준영속 상태
        - 영속 -> 준영속
        - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) -> 영속성 컨텍스트에서 더이상 관리하지마! JPA에서 관리안한다.
        - 영속성 컨텍스트가 제공하는 기능을 사용 못함
        - 준영속 상태로 만드는 방법
            - em.detach(entity) : 특정 엔티티만 준영속 상태로 전환
            - em.clear() : 영속성 컨텍스트를 완전히 초기화
            - em.close() : 영속성 컨텍스트를 종료


    - 엔티티 매핑
        - 객체와 테이블 매핑 
            - @Entity
                - jpa를 사용해서 테이브르과 매핑할 클래스는 @Entity 필수
                - 기본 생성자 필수(파라미터가 없는 public or protected 생성자)
                - final class, enum, interface, inner class 사용 x
                - 저장할 필드에 final 사용 x
            - @Table

            - 데이터베이스 스키마 자동 생성
                - hibernate.hbm2ddl.auto 
                    - create (기존테이블 삭제 후 다시 생성) --> 운영X
                    - create-drop (create 동일 종료시점에 테이블 drop) --> 운영X
                    - update (변경분만 반영) --> 운영X, 테스트o
                    - validate (엔티티와 테이블이 정상 매핑되었는지만 확인)
                    - none
                - DDL을 애플리케이션 실행 시점에 자동 생성
                - 테이블 중심 -> 객체 중심
                - 개발 장비에서만 사용!!! (생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용)

        - 필드와 컬럼 매핑
            - @Column : 컬럼 매핑
                - nullable = false -> not null 제약조건
                - columnDefinition 가능
            - @Temporal : 날짜 타입 매핑
                - LocalDate, LocalDateTime을 사용할 때는 생략 가능
            - @Enumerated : enum 타입 매핑
                - 주의! ORDINAL 사용X
                - EnumType.ORDINAL: enum 순서를 데이터베이스에 저장
                - EnumType.STRING: enum 이름을 데이터베이스에 저장
            - @Lob : BLOB, CLOB 매핑 
            - @Transient 특정 필드를 컬럼에 매핑하지 않음(매핑 무시)

        - 기본키 매핑 : @Id
            - 직접 할당: @Id만 사용
            - 자동 생성(@GeneratedValue) 
                - IDENTITY: 데이터베이스에 위임, MYSQL 
                    - AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행
한 이후에 ID 값을 알 수 있음
                    - IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행
하고 DB에서 식별자를 조회

                - SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE 
                    - @SequenceGenerator 필요
                    - 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한
데이터베이스 오브젝트(예: 오라클 시퀀스)

                - TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
                    - @TableGenerator 필요
                    - 모든 데이터베이스에 적용 가능
                    - 성능 (테이블락 걸릴수 있음)


                - AUTO: DB에 따라 자동 지정, 기본값

            - 권장하는 식별자 전략
                - Long형 + 대체키 + 키 생성전략 사용


        - 연관관계 매핑 : @ManyToOne, @JoinColumn
            - 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.

            - 방향
                - 테이블
                    - 외래키 하나로 양쪽 조인 가능
                    - 사실 방향이라는 개념이 없음
                - 객체
                    - 참조용 필드가 있는 쪽으로만 참조 가능
                    - 한쪽만 참조하면 단방향
                    - 양쪽이 서로 참조하면 양방향

                - 단방향
                - 양방향
                    - 연관관계의 주인(owner) : 객체 양방향 연관간계는 관리 주인이 필요
                    - 누구를 주인으로 할꺼냐? 외래키가 있는 곳을 주인으로 정하자!
                    - 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자 -> 연관관계 편의 메소드를 생성하자
                    - 무한 루프를조심하자
                        - toString() : 양쪽 객체를 호출해서 무한루프
                        - lombok
                        - JSON 생성 라이브러리
                    - 단방향 매핑만으로도 이미 연관관계 매핑은 완료 
                        - 처음에는 단방향으로 설계를 끝내야함
                        - 그 후 양방향으로 조회관련 설계를 추가한다.. 
                    - 실무에서는 JPQL에서 역방향으로 탐색할 일이 많음...
            
            - 다중성
                - 다대일(N:1)
                    - N이 연관관계의 주인

                - 일대다(1:N)
                    -단뱡향
                        - 1이 연관관계의 주인
                        - 테이블 일대다 관계는 다 N쪽에 외래 키가 있음
                        - 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조
                        - @JoinColumn 을 꼭 사용해야함, 안하면 중간 연계 테이블이 생성 됨
                        - 실무에서 권장하지 않지만 표준 스펙에서 지원
                        - 다대일 단방향을 사용하자..

                    -양방향
                        - 공식적으로 존재 X
                        - @JoinColumn(inserttable=false, updatable=false)
                        - 읽기 전용 필드 사용해서 양방향 처럼 사용하는 방법
                        - 다대일 양방향을 사용하자..

                - 일대일(1:1)
                    - 단방향
                        - 단방향 다대일(@ManyToOne) 매핑과 유사

                    - 양방향
                        - 외래키 있는 곳에 @OneToOne / @JoinColumn 사용
                        - 다른 한쪽에는 @OneToOne(mappedBy="") 읽기전용 객체로 사용

                    - 주 테이블에 외래키
                        - 주 객체가 대상 객체의 참조를 가지는 것 처럼, 주 테이블에 외래 키를 두고 대상 테이블을 찾음
                        - 객체지향 개발자 선호
                        - JPA 매핑 편리
                        - 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
                        - 단점 : 값이 없으면 외래 키에 null 허용

                    - 대상 테이블에 외래 키
                        - 대상 테이블에 외래 키가 존재
                        - 전통적인 데이터베이스 개발자 선호
                        - 장점 : 주테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
                        - 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨

                - 다대다(N:M)
                    - 실무에서 쓰면 안된다...!!
                    - DB는 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함
                    - 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능

                    - 한계 극복
                        - 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)
                        - @ManyToMany -> @OneToMany, @ManyToOne
 
            
        - 고급 매핑
            - 상속관계 매핑
                - 슈퍼타입 -> 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법

                - @Inheritance(strategy=InheritanceType.XXX)
                    - JOIN : 조인 전략 (각각 테이블로 변환) ---> 실무에서 주로 사용, 비지니스 적으로 복잡할때
                        - 장점
                            - 테이블 정규화
                            - 외래키 참조 무결성 제약조건 활용가능
                            - 저장공간 효율화
                        - 단점
                            - 조회시 조인을 많이 사용 -> 성능 저하
                            - 조회 쿼리 복잡
                            - 데이터 저장시 INSERT SQL 2번 호출

                    - SINGLE_TABLE : 단일 테이블 전략 (통합 테이블로 변환) --> 테이블이 정말 단순, 데이터도 없고, 확장가능성 없음
                        - 장점
                            - JPA 기본 전략
                            - 조인이 필요 없으므로, 성능이 제일 잘나옴
                            - 조회 쿼리가 단순
                        - 단점
                            - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
                            - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라 조회 성능이 오히려 느려질 수 있다.

                    - TABLE_PER_CLASS : 구현 클래스마다 테이블 전략 (서브타입 테이블로 변환)
                        - 실무에서 쓰지마~~~!!
                        - 장점
                            - 서브 타입을 명확하게 구분해서 처리할때 효과적
                            - not null 제약조건 사용 가능
                        - 단점
                            - 여러 자식 테이블을 함께 조회할때 성능이 느림 (UNION SQL)
                            - 자식 테이블을 통합해서 쿼리하기 어려움

                - @DiscriminatorColumn(name="DTYPE") 
                - @DiscriminatorValue("XXX") 

            - Mapped Superclass : 매핑 정보 상속
                - 상속관계 매핑 X
                - 엔티티X, 테이블과 매핑X
                - 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공
                - 조회, 검색 불가(em.find(BaseEntity) 불가)
                - 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장

                - 테이블과 관계없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할
                - 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을때 사용
                - 참고 : @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능

                
        - 프록시와 연관관계 관리
            - 프록시 (실무에서 거의 안씀)
                - em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
                - em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

                - 특징
                    - 프록시 객체는 처음 사용할 때 한 번만 초기화 (실제 클래스와 겉 모양이 같다.)
                    - 프록시 객체 초기화
                        - 객체 호출 -> 객체 초기화 요청 -> 영속성 컨텍스트 -> DB 조회 -> 실제 Entity 생성 -> 프록시 객체에서 실제 Entity 호출
                        - 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능

                    - 실제 클래스를 상속 받아서 만들어짐, 따라서 타입 체크시 주의해야함 
                        - == 비교 실패
                        - 대신 instance of 객체 사용

                    - 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환

                    - 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때 프록시를 초기화 하면 문제 발생
                        - 하이버네이트는 LazyInitializationException 예외가 생성

                    - 사용하는 입장에서는 진짜 객체인지, 프록시 객체인지 구분하지 않고 사용하면 됨(이론상)

                - 확인  
                    - 프록시 인스턴스의 초기화 여부 확인
                        - emf.getPersistenceUnitUtils().isLoaded(Object entity)
                    - 프록시 클래스 확인 방법
                        - entity.getClass().getName() 출력
                    - 프록시 강제 초기화
                        - org.hibernate.Hibernate.initialize(entity);
                        - jpa 표준은 강제 초기화 없음


            - 즉시 로딩과 지연 로딩
                - 지연로딩 : LAZY를 사용해서 프록시로 조회
                    - 가급적 지연로딩만 사용 (특히 실무에서!)
                    - @ManyToOne, @OneToOne 기본이 즉시 로딩 --> LAZY로 설정
                    - @OneToMany, @ManyToMany 는 기본이 지연 로딩
                    
                - 즉시로딩 
                    - 예상하지 못한 SQL이 발생
                    - JPQL 에서 N+1 문제를 일으킨다.

                - 활용
                    - 모든 연관관계에서 지연 로딩을 사용해라
                    - 실무에서 즉시 로딩을 사용하지 마라
                    - JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라..
            

            - 영속성 전이(CASCADE)와 고아 객체
                - 영속성 전이
                    - 특정 엔티티를 영속 상태로 만들때 연관된 엔티티도 함께 영속 상태로 만들고 싶을때
                    - 예: 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장

                    - 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음
                    - 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐
                    - 주로 ALL or 저장할때만 쓰는 Persist 옵션을 사용

                - 고아 객체
                    - 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
                    - orphanRmoval = true (객체 제거 기능)
                    - 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
                    - 참조하는 곳이 하나일 때 사용해야함!
                    - 특정 엔티티가 개인 소유할때 사용
                    - @OneToOne, @OneToMany 만 가능
                    - 예 : 게시판의 첨부파일...

                - CasecadeType.ALL + orphanRmoval = true
                    - 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거
                    - 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 관리할 수 있음
                    - 도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용

        - jpa 데이터 타입 분류
            - 엔티티 타입
                - @Entity로 정의하는 객체
                - 데이터가 변해도 식별자가 지속해서 추적 가능
                    - 예 : 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능
                - 식별자가 있고 공유할수 있다.

            - 값 타입
                - 값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념이다.
                - 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.
                - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
                - 식별자가 없고 값만 있으므로 변경시 추적 불가
                    - 예 : 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체

                - 기본값 타입
                    - 자바 기본 타입(int, double..)
                        - 생명주기를 엔티티의 의존
                            - 예 : 회원을 삭제하면 이름/나이 필드도 함께 삭제
                        - 값 타입은 공유하면 X 
                            - 예 : 회원 이름 변경시 다른 회원의 이름도 함계 변경되면 안됨
                            - int, double 같은 기본 타입(primitive type)은 절대 공유X
                            - 기본 타입은 항상 값을 복사함
                            - 대신 값(인스턴스)를 복사해서 사용
                                - 항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다.
                                - 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다.
                                - 자바 기본 타입에 값을 대입하면 값을 복사한다.
                            
                    - 래퍼 클래스(Integer, Long..)
                        - Integer 같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경X
                        - 객체 타입은 참조를 전달
                        - 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.
                        - 객체의 공유 참조는 피할 수 없다.

                        - 불변 객체
                            - 객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단
                            - 값 타입은 불변 객체(immutable object)로 설계해야함
                            - 불변 객체: 생성 시점 이후 절대 값을 변경할 수 없는 객체
                            - 생성자로만 값을 설정하고 수정자(setter)를 만들지 않으면 됨
                            - 참고 : Integer, String은 자바가 제공하는 대표적인 불변 객체
                        - 값을 바꾸고 싶으면 오브젝트를 통으로 바꿔끼는걸 권장

                    - String


                - 값 타입 비교
                    - 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야 함
                    - 동일성(identity) 비교 : 인스턴스의 참조 값을 비교, == 사용
                    - 동등성(equivalence) 비교 : 인스턴스의 값을 비교, equals() 사용
                        - equals 메소드 재정의 필요(주로 모든 필드 사용해서 비교)


                - 임베디드 타입 (embedded type : 복합 값 타입)
                    - 새로운 값 타입을 직접 정의할 수 있음
                    - 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함
                    - int, String 과 같은 값 타입 (변경하면 끝)

                    - 장점
                        - 재사용
                        - 높은 응집도
                        - Period.isWork() 처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음
                        - 임베디드 타입을 포함한 모든 값 타입은, 값 타입을소유한 엔티티에 생명주기를 의존함
                    
                    - 사용법
                        - @Embeddable : 값 타입을 정의하는 곳에 표시
                        - @Embedded : 값 타입을 사용하는 곳에 표시
                        - 기본 생성자 필수

                    - 임베디드 타입과 테이블 매핑
                        - 임베디드 타입은 엔티티의 값일 뿐이다.
                        - 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.
                        - 객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능
                        - 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래수의 수가 더 많음

                        - AttributeOverride : 속성 재정의
                            - 한 엔티티에서 값은 값 타입을 사용하면? 컬럼 명이 중복됨
                            - AttributeOverride 사용하여 중복 회피
                        -


                - 컬렉션 값 타입 (collection value type)
                    - 값 타입을 하나 이상 저장할 때 사용
                    - @ElementCollection, @CollectionTable 사용
                    - 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.
                    - 컬렉션을 저장하기 위한 별도의 테이블이 필요함
                    - 값 타입 컬렉션도 지연 로딩 전략 사용
                    - 값 타입 컬렉션은 영속성 전에(Cascade) + 고아 객체 제거 기능을 필수로 가진다.
                    - 값을 바꾸고 싶으면 오브젝트를 통으로 바꿔끼는걸 권장
                        - list.remove 후 list.add (equals(), hashCode() 재정의 중요!)


                    - 값 타입 컬렉션의 제약사항
                        - 값 타입은 엔티티와 다르게 식별자 개념이 없다.
                        - 값은 변경하면 추적이 어렵다.
                        - 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터을 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다.
                        - 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야 함 : null 입력 X, 중복 저장 X
                        - 실무에서 최대한 쓰는것을 지양해야 할듯...... 일대다 매핑으로 푸는것이 맞을듯..
                        







