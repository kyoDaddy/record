-jpa 기본

    - 엔티티 매니저?
        - 생명주기
            - 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
            - 영속(managed) : 영속성 컨텍스트에 관리되는 상태
            - 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
            - 삭제(removed) : 삭제된 상태

    - 영속성 컨텍스트
        - 엔티티를 영구 저장하는 환경 (entityManager.persist(entity))
        - 엔티티 매니저를 통해 영속성 컨텍스트에 접근
        - 1차캐시
        - 동일성 보장
        - 트랙잭션을 지원하는 쓰기 지연
        - 변경감지 (dirty checking)
        - 지연로딩 (lazy loading)
        
    - 플러시
        - 영속성 컨텍스트의 변경내용을 데이터베이스에 반영(동기화)
        - 변경감지 -> 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 -> 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록,수정,삭제 쿼리)
        - 영속성 컨텍스트를 플러시하는 방법
            - em.flush : 직접호출
            - 트랙잭션 커밋 : 플러시 자동 호출
            - JPQL 쿼리 실행 : 플러시 자동 호출
        - 영속성 컨텍스트를 비우는게 아님
        - 트랜잭션이라는 작업 단위가 중요 - 커밋 직전에만 동기화 하면 됨

    - 준영속 상태
        - 영속 -> 준영속
        - 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) -> 영속성 컨텍스트에서 더이상 관리하지마! JPA에서 관리안한다.
        - 영속성 컨텍스트가 제공하는 기능을 사용 못함
        - 준영속 상태로 만드는 방법
            - em.detach(entity) : 특정 엔티티만 준영속 상태로 전환
            - em.clear() : 영속성 컨텍스트를 완전히 초기화
            - em.close() : 영속성 컨텍스트를 종료


    - 엔티티 매핑
        - 객체와 테이블 매핑 
            - @Entity
                - jpa를 사용해서 테이브르과 매핑할 클래스는 @Entity 필수
                - 기본 생성자 필수(파라미터가 없는 public or protected 생성자)
                - final class, enum, interface, inner class 사용 x
                - 저장할 필드에 final 사용 x
            - @Table

            - 데이터베이스 스키마 자동 생성
                - hibernate.hbm2ddl.auto 
                    - create (기존테이블 삭제 후 다시 생성) --> 운영X
                    - create-drop (create 동일 종료시점에 테이블 drop) --> 운영X
                    - update (변경분만 반영) --> 운영X, 테스트o
                    - validate (엔티티와 테이블이 정상 매핑되었는지만 확인)
                    - none
                - DDL을 애플리케이션 실행 시점에 자동 생성
                - 테이블 중심 -> 객체 중심
                - 개발 장비에서만 사용!!! (생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용)

        - 필드와 컬럼 매핑
            - @Column : 컬럼 매핑
                - nullable = false -> not null 제약조건
                - columnDefinition 가능
            - @Temporal : 날짜 타입 매핑
                - LocalDate, LocalDateTime을 사용할 때는 생략 가능
            - @Enumerated : enum 타입 매핑
                - 주의! ORDINAL 사용X
                - EnumType.ORDINAL: enum 순서를 데이터베이스에 저장
                - EnumType.STRING: enum 이름을 데이터베이스에 저장
            - @Lob : BLOB, CLOB 매핑 
            - @Transient 특정 필드를 컬럼에 매핑하지 않음(매핑 무시)

        - 기본키 매핑 : @Id
            - 직접 할당: @Id만 사용
            - 자동 생성(@GeneratedValue) 
                - IDENTITY: 데이터베이스에 위임, MYSQL 
                    - AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행
한 이후에 ID 값을 알 수 있음
                    - IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행
하고 DB에서 식별자를 조회

                - SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE 
                    - @SequenceGenerator 필요
                    - 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한
데이터베이스 오브젝트(예: 오라클 시퀀스)

                - TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
                    - @TableGenerator 필요
                    - 모든 데이터베이스에 적용 가능
                    - 성능 (테이블락 걸릴수 있음)


                - AUTO: DB에 따라 자동 지정, 기본값

            - 권장하는 식별자 전략
                - Long형 + 대체키 + 키 생성전략 사용


        - 연관관계 매핑 : @ManyToOne, @JoinColumn
            - 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.

            - 방향
                - 테이블
                    - 외래키 하나로 양쪽 조인 가능
                    - 사실 방향이라는 개념이 없음
                - 객체
                    - 참조용 필드가 있는 쪽으로만 참조 가능
                    - 한쪽만 참조하면 단방향
                    - 양쪽이 서로 참조하면 양방향

                - 단방향
                - 양방향
                    - 연관관계의 주인(owner) : 객체 양방향 연관간계는 관리 주인이 필요
                    - 누구를 주인으로 할꺼냐? 외래키가 있는 곳을 주인으로 정하자!
                    - 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자 -> 연관관계 편의 메소드를 생성하자
                    - 무한 루프를조심하자
                        - toString() : 양쪽 객체를 호출해서 무한루프
                        - lombok
                        - JSON 생성 라이브러리
                    - 단방향 매핑만으로도 이미 연관관계 매핑은 완료 
                        - 처음에는 단방향으로 설계를 끝내야함
                        - 그 후 양방향으로 조회관련 설계를 추가한다.. 
                    - 실무에서는 JPQL에서 역방향으로 탐색할 일이 많음...
            
            - 다중성
                - 다대일(N:1)
                    - N이 연관관계의 주인

                - 일대다(1:N)
                    -단뱡향
                        - 1이 연관관계의 주인
                        - 테이블 일대다 관계는 다 N쪽에 외래 키가 있음
                        - 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조
                        - @JoinColumn 을 꼭 사용해야함, 안하면 중간 연계 테이블이 생성 됨
                        - 실무에서 권장하지 않지만 표준 스펙에서 지원
                        - 다대일 단방향을 사용하자..

                    -양방향
                        - 공식적으로 존재 X
                        - @JoinColumn(inserttable=false, updatable=false)
                        - 읽기 전용 필드 사용해서 양방향 처럼 사용하는 방법
                        - 다대일 양방향을 사용하자..

                - 일대일(1:1)
                    - 단방향
                        - 단방향 다대일(@ManyToOne) 매핑과 유사

                    - 양방향
                        - 외래키 있는 곳에 @OneToOne / @JoinColumn 사용
                        - 다른 한쪽에는 @OneToOne(mappedBy="") 읽기전용 객체로 사용

                    - 주 테이블에 외래키
                        - 주 객체가 대상 객체의 참조를 가지는 것 처럼, 주 테이블에 외래 키를 두고 대상 테이블을 찾음
                        - 객체지향 개발자 선호
                        - JPA 매핑 편리
                        - 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
                        - 단점 : 값이 없으면 외래 키에 null 허용

                    - 대상 테이블에 외래 키
                        - 대상 테이블에 외래 키가 존재
                        - 전통적인 데이터베이스 개발자 선호
                        - 장점 : 주테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
                        - 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨

                - 다대다(N:M)
                    - 실무에서 쓰면 안된다...!!
                    - DB는 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함
                    - 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능

                    - 한계 극복
                        - 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)
                        - @ManyToMany -> @OneToMany, @ManyToOne
 
            
        - 고급 매핑
            - 상속관계 매핑
                - 슈퍼타입 -> 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법

                - @Inheritance(strategy=InheritanceType.XXX)
                    - JOIN : 조인 전략 (각각 테이블로 변환) ---> 실무에서 주로 사용, 비지니스 적으로 복잡할때
                        - 장점
                            - 테이블 정규화
                            - 외래키 참조 무결성 제약조건 활용가능
                            - 저장공간 효율화
                        - 단점
                            - 조회시 조인을 많이 사용 -> 성능 저하
                            - 조회 쿼리 복잡
                            - 데이터 저장시 INSERT SQL 2번 호출

                    - SINGLE_TABLE : 단일 테이블 전략 (통합 테이블로 변환) --> 테이블이 정말 단순, 데이터도 없고, 확장가능성 없음
                        - 장점
                            - JPA 기본 전략
                            - 조인이 필요 없으므로, 성능이 제일 잘나옴
                            - 조회 쿼리가 단순
                        - 단점
                            - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
                            - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라 조회 성능이 오히려 느려질 수 있다.

                    - TABLE_PER_CLASS : 구현 클래스마다 테이블 전략 (서브타입 테이블로 변환)
                        - 실무에서 쓰지마~~~!!
                        - 장점
                            - 서브 타입을 명확하게 구분해서 처리할때 효과적
                            - not null 제약조건 사용 가능
                        - 단점
                            - 여러 자식 테이블을 함께 조회할때 성능이 느림 (UNION SQL)
                            - 자식 테이블을 통합해서 쿼리하기 어려움

                - @DiscriminatorColumn(name="DTYPE") 
                - @DiscriminatorValue("XXX") 

            - Mapped Superclass : 매핑 정보 상속
                - 상속관계 매핑 X
                - 엔티티X, 테이블과 매핑X
                - 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공
                - 조회, 검색 불가(em.find(BaseEntity) 불가)
                - 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장

                - 테이블과 관계없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할
                - 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을때 사용
                - 참고 : @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능

                
        - 프록시와 연관관계 관리
            - 프록시 (실무에서 거의 안씀)
                - em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
                - em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

                - 특징
                    - 프록시 객체는 처음 사용할 때 한 번만 초기화 (실제 클래스와 겉 모양이 같다.)
                    - 프록시 객체 초기화
                        - 객체 호출 -> 객체 초기화 요청 -> 영속성 컨텍스트 -> DB 조회 -> 실제 Entity 생성 -> 프록시 객체에서 실제 Entity 호출
                        - 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능

                    - 실제 클래스를 상속 받아서 만들어짐, 따라서 타입 체크시 주의해야함 
                        - == 비교 실패
                        - 대신 instance of 객체 사용

                    - 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환

                    - 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때 프록시를 초기화 하면 문제 발생
                        - 하이버네이트는 LazyInitializationException 예외가 생성

                    - 사용하는 입장에서는 진짜 객체인지, 프록시 객체인지 구분하지 않고 사용하면 됨(이론상)

                - 확인  
                    - 프록시 인스턴스의 초기화 여부 확인
                        - emf.getPersistenceUnitUtils().isLoaded(Object entity)
                    - 프록시 클래스 확인 방법
                        - entity.getClass().getName() 출력
                    - 프록시 강제 초기화
                        - org.hibernate.Hibernate.initialize(entity);
                        - jpa 표준은 강제 초기화 없음


            - 즉시 로딩과 지연 로딩
                - 지연로딩 : LAZY를 사용해서 프록시로 조회
                    - 가급적 지연로딩만 사용 (특히 실무에서!)
                    - @ManyToOne, @OneToOne 기본이 즉시 로딩 --> LAZY로 설정
                    - @OneToMany, @ManyToMany 는 기본이 지연 로딩
                    
                - 즉시로딩 
                    - 예상하지 못한 SQL이 발생
                    - JPQL 에서 N+1 문제를 일으킨다.

                - 활용
                    - 모든 연관관계에서 지연 로딩을 사용해라
                    - 실무에서 즉시 로딩을 사용하지 마라
                    - JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라..
            

            - 영속성 전이(CASCADE)와 고아 객체
                - 영속성 전이
                    - 특정 엔티티를 영속 상태로 만들때 연관된 엔티티도 함께 영속 상태로 만들고 싶을때
                    - 예: 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장

                    - 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음
                    - 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐
                    - 주로 ALL or 저장할때만 쓰는 Persist 옵션을 사용

                - 고아 객체
                    - 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
                    - orphanRmoval = true (객체 제거 기능)
                    - 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
                    - 참조하는 곳이 하나일 때 사용해야함!
                    - 특정 엔티티가 개인 소유할때 사용
                    - @OneToOne, @OneToMany 만 가능
                    - 예 : 게시판의 첨부파일...

                - CasecadeType.ALL + orphanRmoval = true
                    - 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거
                    - 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 관리할 수 있음
                    - 도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용







